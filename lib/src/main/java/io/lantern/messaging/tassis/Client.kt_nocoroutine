/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.lantern.messaging.tassis

import com.google.protobuf.ByteString
import com.google.protobuf.GeneratedMessageLite
import org.whispersystems.libsignal.DeviceId
import org.whispersystems.libsignal.SignalProtocolAddress
import org.whispersystems.libsignal.ecc.ECPublicKey
import java.nio.ByteBuffer
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger

/**
 * Represents an error from tassis
 */
class TassisError(val name: String, val description: String) : Exception("${name}: ${description}")

/**
 * Callback interface for receiving asynchronous results.
 */
interface Callback<T> {
    fun onSuccess(result: T)

    fun onError(err: Throwable)
}

/**
 * A handler for messages received from a transport (e.g. a websocket connection)
 */
interface MessageHandler {
    /**
     * Called whenever a new message arrives from the remote end
     */
    fun onMessage(data: ByteBuffer?)

    /**
     * Called when the transport has been closed to let the MessageHandler know that it should close
     * too. If the transport was closed due to an error condition, err will be populated.
     */
    fun onClose(err: Throwable? = null)
}

/**
 * A facility for sending messages (e.g. a websocket connection)
 */
interface Transport {
    fun setHandler(handler: MessageHandler)

    fun send(data: ByteArray)

    fun close()
}

/**
 * A factory for Transports.
 */
interface TransportFactory {
    fun build(cb: Callback<Transport>)
}

/**
 * Represents an inbound message from another user. Call ack() once the message has been durably
 * recorded so that it can be deleted server-side.
 */
class InboundMessage internal constructor(
    private val msg: Messages.Message,
    private val client: AuthenticatedClient
) {
    val data: ByteString
        get() = msg.inboundMessage

    fun ack() {
        client.send(
            Messages.Message.newBuilder().setSequence(msg.sequence)
                .setAck(Messages.Ack.newBuilder().build()).build()
        )
    }
}

/**
 * A delegate for receiving lifecycle callbacks from a Client connection.
 */
interface ClientDelegate {
    /**
     * Called when a client closes. If the client closed due to an exception, err will be populated
     * with the relevant exception.
     */
    fun onClose(err: Throwable? = null)
}

/**
 * A delegate for receiving asynchronous callbacks on an authenticated client connection.
 */
interface AuthenticatedClientDelegate : ClientDelegate {
    /**
     * Called when AuthChallenge is received. Should generate the corresponding AuthResponse to
     * complete the authentication.
     */
    fun authenticate(challenge: Messages.AuthChallenge): Messages.AuthResponse

    /**
     * Called when tassis notifies us that one-time pre keys are getting low.
     */
    fun onPreKeysLow(msg: Messages.PreKeysLow)

    /**
     * Called when we receive an inbound message from another user device via tassis.
     */
    fun onInboundMessage(msg: InboundMessage)
}

/**
 * Client provides a mechanism for talking to a tassis service.
 */
abstract class Client<D : ClientDelegate>(
    private val transport: Transport,
    protected val delegate: D
) : MessageHandler {
    private val msgSequence = AtomicInteger()
    protected val pending = ConcurrentHashMap<Int, Callback<Any?>>()

    init {
        transport.setHandler(this)
    }

    protected fun send(detail: GeneratedMessageLite<*, *>, callback: Callback<*>? = null) {
        val msg = buildMessage(detail)
        if (callback != null) {
            pending[msg.sequence] = callback as Callback<Any?>
        }
        send(msg)
    }

    internal fun send(msg: Messages.Message) {
        transport.send(msg.toByteArray())
    }

    protected fun nextMessage(): Messages.Message.Builder {
        return Messages.Message.newBuilder().setSequence(msgSequence.incrementAndGet())
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.ACK -> pending[msg.sequence]?.onSuccess(null)
            Messages.Message.PayloadCase.ERROR -> pending[msg.sequence]?.onError(
                TassisError(
                    msg.error!!.name,
                    msg.error!!.description
                )
            )
            else -> println("unknown payload type ${msg.payloadCase}")
        }
    }

    fun close() {
        transport.close()
    }

    override fun onClose(err: Throwable?) {
        pending.clear()
        delegate.onClose(err)
    }
}

/**
 * Authenticated client is a Client that has authenticated against the tassis cluster and can be
 * used for operations that require authentication.
 */
class AuthenticatedClient private constructor(
    transport: Transport,
    delegate: AuthenticatedClientDelegate,
    private val connectCallback: Callback<AuthenticatedClient>
) : Client<AuthenticatedClientDelegate>(transport, delegate) {
    private val wrappedConnectCallback = object : Callback<Void?> {
        override fun onSuccess(result: Void?) {
            connectCallback.onSuccess(this@AuthenticatedClient)
        }

        override fun onError(err: Throwable) {
            connectCallback.onError(err)
            close() // don't report error again since we already reported it to the callback
        }
    }

    fun register(signedPreKey: ByteArray, preKeys: List<ByteArray>, callback: Callback<Void>) {
        val msg = nextMessage().setRegister(
            Messages.Register.newBuilder().setSignedPreKey(signedPreKey.byteString())
                .addAllOneTimePreKeys(preKeys.map { it.byteString() }).build()
        )

        send(msg.build(), callback)
    }

    fun unregister(callback: Callback<Void>) {
        send(Messages.Unregister.newBuilder().build(), callback)
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.AUTHCHALLENGE -> send(
                delegate.authenticate(msg.authChallenge),
                wrappedConnectCallback
            )
            Messages.Message.PayloadCase.PREKEYS -> pending[msg.sequence]?.onSuccess(msg.preKeys)
            Messages.Message.PayloadCase.PREKEYSLOW -> delegate.onPreKeysLow(msg.preKeysLow)
            Messages.Message.PayloadCase.INBOUNDMESSAGE -> delegate.onInboundMessage(
                InboundMessage(
                    msg,
                    this
                )
            )
            else -> super.onMessage(data)
        }
    }

    companion object {
        /**
         * Connects an AuthenticatedClient using the given transportFactory.
         */
        fun connect(
            transportFactory: TransportFactory,
            delegate: AuthenticatedClientDelegate,
            connectCallback: Callback<AuthenticatedClient>
        ) {
            transportFactory.build(object : Callback<Transport> {
                override fun onSuccess(result: Transport) {
                    AuthenticatedClient(result, delegate, connectCallback)
                }

                override fun onError(err: Throwable) {
                    connectCallback.onError(err)
                }
            })
        }
    }
}

/**
 * Anonymous client is a client that does not authenticate against the tassis service. It is used
 * for anonymous operations like requesting pre keys and sending sealed sender messages.
 */
class AnonymousClient private constructor(
    transport: Transport,
    delegate: ClientDelegate,
    private val connectCallback: Callback<AnonymousClient>
) : Client<ClientDelegate>(transport, delegate) {
    fun requestPreKeys(
        identityKey: ECPublicKey,
        knownDeviceIds: List<DeviceId>>: Messages.PreKeys
    ) {
        val requestPreKeys = Messages.RequestPreKeys.newBuilder()
            .setIdentityKey(identityKey.bytes.byteString())
        knownDeviceIds.forEach { requestPreKeys.addKnownDeviceIds(it.bytes.byteString()) }
        val msg = nextMessage().setRequestPreKeys(requestPreKeys.build()).build()
        send(msg, callback)
    }

    fun sendUnidentifiedSenderMessage(
        to: SignalProtocolAddress,
        unidentifiedSenderMessage: ByteArray
    ) {
        val msg = nextMessage().setOutboundMessage(
            Messages.OutboundMessage.newBuilder().setTo(
                Messages.Address.newBuilder()
                    .setIdentityKey(to.identityKey.bytes.byteString())
                    .setDeviceId(to.deviceId.bytes.byteString())
            ).setUnidentifiedSenderMessage(unidentifiedSenderMessage.byteString())).build()
        send (msg, callback)
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.AUTHCHALLENGE -> connectCallback.onSuccess(this)
            Messages.Message.PayloadCase.PREKEYS -> pending[msg.sequence]?.onSuccess(msg.preKeys)
            else -> super.onMessage(data)
        }
    }

    companion object {
        /**
         * Connects an AnonymousClient using the given transportFactory.
         */
        fun connect(
            transportFactory: TransportFactory,
            delegate: ClientDelegate,
            connectCallback: Callback<AnonymousClient>
        ) {
            transportFactory.build(object : Callback<Transport> {
                override fun onSuccess(result: Transport) {
                    AnonymousClient(result, delegate, connectCallback)
                }

                override fun onError(err: Throwable) {
                    connectCallback.onError(err)
                }
            })
        }
    }
}

fun ByteArray.message(): Messages.Message {
    return Messages.Message.parseFrom(this)
}

fun ByteArray.byteString(): ByteString {
    return ByteString.copyFrom(this)
}