/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.lantern.messaging.tassis

import com.google.protobuf.ByteString
import mu.KotlinLogging
import org.whispersystems.libsignal.DeviceId
import org.whispersystems.libsignal.SignalProtocolAddress
import org.whispersystems.libsignal.ecc.ECPublicKey
import java.nio.ByteBuffer
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger

internal val logger = KotlinLogging.logger {}

/**
 * Callback interface for receiving asynchronous results.
 */
interface Callback<T> {
    fun onSuccess(result: T)

    fun onError(err: Throwable)
}

internal class AckCallback(private val cb: Callback<Unit>) : Callback<Messages.Ack> {
    override fun onSuccess(result: Messages.Ack) {
        try {
            cb.onSuccess(Unit)
        } catch (t: Throwable) {
            logger.error("error on client callback: $t.message", t)
        }
    }

    override fun onError(err: Throwable) {
        cb.onError(err)
    }
}

/**
 * A handler for messages received from a transport (e.g. a websocket connection)
 */
interface MessageHandler {
    /**
     * A place for the Transport to register itself
     */
    fun setTransport(transport: Transport)

    /**
     * Called if there's an error connecting the Transport
     */
    fun onConnectError(err: Throwable)

    /**
     * Called whenever a new message arrives from the remote end
     */
    fun onMessage(data: ByteBuffer?)

    /**
     * Called when the transport has been closed to let the MessageHandler know that it should close
     * too. If the transport was closed due to an error condition, err will be populated.
     */
    fun onClose(err: Throwable? = null)
}

/**
 * A facility for sending messages (e.g. a websocket connection)
 */
interface Transport {
    fun send(data: ByteArray)

    fun close()
}

/**
 * A factory for Transports.
 */
interface TransportFactory {
    fun connect(handler: MessageHandler)
}

/**
 * Represents an error from tassis
 */
data class TassisError(val name: String, val description: String) :
    RuntimeException("${name}: $description")


/**
 * Represents an inbound message from another user. Call ack() once the message has been durably
 * recorded so that it can be deleted server-side.
 */
class InboundMessage internal constructor(
    private val msg: Messages.Message,
    private val client: AuthenticatedClient
) {
    val data: ByteString
        get() = msg.inboundMessage

    fun ack() {
        try {
            client.send(
                Messages.Message.newBuilder().setSequence(msg.sequence)
                    .setAck(Messages.Ack.newBuilder().build()).build()
            )
        } catch (t: Throwable) {
            logger.trace("ack failed with error '${t.message}', this can happen if the client connection was closed before we could process the inbound message, in which case we might get the same message again later, which is okay")
        }
    }
}

/**
 * A delegate for receiving lifecycle callbacks from a Client connection.
 */
interface ClientDelegate {
    /**
     * Called if there's an error connecting the Client
     */
    fun onConnectError(err: Throwable)

    /**
     * Called when a client closes. If the client closed due to an exception, err will be populated
     * with the relevant exception.
     */
    fun onClose(err: Throwable? = null)
}

/**
 * A delegate for receiving asynchronous callbacks on an authenticated client connection.
 */
interface AuthenticatedClientDelegate : ClientDelegate {
    /**
     * Called once the client has been connected
     */
    fun onConnected(client: AuthenticatedClient)

    /**
     * Used to sign the response to an AuthChallenge
     */
    fun signLogin(loginBytes: ByteArray): ByteArray

    /**
     * Called when tassis notifies us that one-time pre keys are getting low.
     */
    fun onPreKeysLow(numPreKeysRequested: Int)

    /**
     * Called when we receive an inbound message from another user device via tassis.
     */
    fun onInboundMessage(msg: InboundMessage)
}

interface AnonymousClientDelegate : ClientDelegate {
    /**
     * Called once the client has been connected
     */
    fun onConnected(client: AnonymousClient)
}

/**
 * Client provides a mechanism for talking to a tassis service.
 */
abstract class Client<D : ClientDelegate>(
    protected val delegate: D,
) : MessageHandler {
    private lateinit var transport: Transport
    private val msgSequence = AtomicInteger(1)
    protected val pending = ConcurrentHashMap<Int, Callback<Any?>>()

    override fun setTransport(transport: Transport) {
        this.transport = transport
    }

    override fun onConnectError(err: Throwable) {
        delegate.onConnectError(err)
    }

    internal fun send(msg: Messages.Message, callback: Callback<*>? = null) {
        if (callback != null) {
            pending[msg.sequence] = callback as Callback<Any?>
        }
        transport.send(msg.toByteArray())
    }

    protected fun nextMessage(): Messages.Message.Builder {
        return Messages.Message.newBuilder().setSequence(msgSequence.incrementAndGet())
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        onMessage(msg)
    }

    protected fun onMessage(msg: Messages.Message) {
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.ACK -> {
                pending.remove(msg.sequence)?.onSuccess(msg.ack)
            }
            Messages.Message.PayloadCase.ERROR -> pending.remove(msg.sequence)?.onError(
                TassisError(
                    msg.error!!.name,
                    msg.error!!.description
                )
            )
            else -> println("unknown payload type ${msg.payloadCase}")
        }
    }

    fun close() {
        transport.close()
    }

    override fun onClose(err: Throwable?) {
        delegate.onClose(err)
        val finalErr = err ?: ClientClosedException()
        pending.values.forEach {
            it.onError(finalErr)
        }
    }
}

/**
 * Authenticated client is a Client that has authenticated against the tassis cluster and can be
 * used for operations that require authentication.
 */
class AuthenticatedClient(
    private val identityKey: ECPublicKey,
    private val deviceId: DeviceId,
    delegate: AuthenticatedClientDelegate
) : Client<AuthenticatedClientDelegate>(delegate) {
    fun register(signedPreKey: ByteArray, preKeys: List<ByteArray>, cb: Callback<Unit>) {
        val msg = nextMessage().setRegister(
            Messages.Register.newBuilder().setSignedPreKey(signedPreKey.byteString())
                .addAllOneTimePreKeys(preKeys.map { it.byteString() }).build()
        ).build()
        send(msg, AckCallback(cb))
    }

    fun unregister(cb: Callback<Unit>) {
        val msg = nextMessage().setUnregister(Messages.Unregister.newBuilder().build()).build()
        send(msg, AckCallback(cb))
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.AUTHCHALLENGE -> processAuth(msg.authChallenge)
            Messages.Message.PayloadCase.PREKEYS -> pending.remove(msg.sequence)
                ?.onSuccess(msg.preKeys)
            Messages.Message.PayloadCase.PREKEYSLOW -> delegate.onPreKeysLow(msg.preKeysLow.keysRequested)
            Messages.Message.PayloadCase.INBOUNDMESSAGE -> delegate.onInboundMessage(
                InboundMessage(
                    msg,
                    this
                )
            )
            else -> super.onMessage(msg)
        }
    }

    private fun processAuth(challenge: Messages.AuthChallenge) {
        val login = Messages.Login.newBuilder()
            .setNonce(challenge.nonce)
            .setAddress(
                Messages.Address.newBuilder()
                    .setIdentityKey(identityKey.bytes.byteString())
                    .setDeviceId(deviceId.bytes.byteString())
            ).build()
        val loginBytes = login.toByteArray()
        val signature = delegate.signLogin(loginBytes)
        val authResponse = Messages.Message.newBuilder().setAuthResponse(
            Messages.AuthResponse.newBuilder()
                .setLogin(loginBytes.byteString())
                .setSignature(signature.byteString())
        ).build()
        try {
            send(authResponse, object : Callback<Messages.Ack> {
                override fun onSuccess(result: Messages.Ack) {
                    delegate.onConnected(this@AuthenticatedClient)
                }

                override fun onError(err: Throwable) {
                    close()
                    onConnectError(err)
                }
            })
        } catch (err: Throwable) {
            close()
            onConnectError(err)
        }
    }
}

/**
 * Anonymous client is a client that does not authenticate against the tassis service. It is used
 * for anonymous operations like requesting pre keys and sending sealed sender messages.
 */
class AnonymousClient(delegate: AnonymousClientDelegate) :
    Client<AnonymousClientDelegate>(delegate) {
    fun retrievePreKeys(
        identityKey: ECPublicKey,
        knownDeviceIds: List<DeviceId>,
        cb: Callback<List<Messages.PreKey>>
    ) {
        val requestPreKeys = Messages.RequestPreKeys.newBuilder()
            .setIdentityKey(identityKey.bytes.byteString())
        knownDeviceIds.forEach { requestPreKeys.addKnownDeviceIds(it.bytes.byteString()) }
        val msg = nextMessage().setRequestPreKeys(requestPreKeys.build()).build()
        send(msg, object : Callback<Messages.PreKeys> {
            override fun onSuccess(result: Messages.PreKeys) {
                try {
                    cb.onSuccess(result.preKeysList)
                } catch (t: Throwable) {
                    logger.error("error after retrieving pre keys: $t.message", t)
                }
            }

            override fun onError(err: Throwable) {
                cb.onError(err)
            }
        })
    }

    fun sendUnidentifiedSenderMessage(
        to: SignalProtocolAddress,
        unidentifiedSenderMessage: ByteArray,
        cb: Callback<Unit>
    ) {
        val msg = nextMessage().setOutboundMessage(
            Messages.OutboundMessage.newBuilder().setTo(
                Messages.Address.newBuilder()
                    .setIdentityKey(to.identityKey.bytes.byteString())
                    .setDeviceId(to.deviceId.bytes.byteString())
            ).setUnidentifiedSenderMessage(unidentifiedSenderMessage.byteString())
        ).build()
        send(msg, AckCallback(cb))
    }

    override fun onMessage(data: ByteBuffer?) {
        val msg = Messages.Message.parseFrom(data)
        when (msg.payloadCase) {
            Messages.Message.PayloadCase.AUTHCHALLENGE -> delegate.onConnected(this)
            Messages.Message.PayloadCase.PREKEYS -> pending.remove(msg.sequence)
                ?.onSuccess(msg.preKeys)
            else -> super.onMessage(msg)
        }
    }
}

fun ByteArray.message(): Messages.Message {
    return Messages.Message.parseFrom(this)
}

fun ByteArray.byteString(): ByteString {
    return ByteString.copyFrom(this)
}

class ClientClosedException : Exception("Client closed")